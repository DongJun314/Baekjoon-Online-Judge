** 핵심 **
1. 핵심은 4차원 방문배열을 통해서 두 동전에 방문 처리를 한다
2. 동전 두개는 문제 지문에서도 나왔듣이, 같이 움직이기 때문에 하나의 구조체로 묶어서 관리한다
3. 너비 우선 탐색은 방문배열을 사용하지 않을 경우 무한으로 돌기에 방문처리를 꼭해야한다
4. 추가적으로 두 동전 중 하나만 떨어진 경우도 생각해야하지만, 두 동전이 같이 떨어지는 경우의 수도 계산해야한다

==============================================================================================================

#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;

struct COINS
{
    int iRowA{ 0 }, iColA{ 0 }, iRowB{ 0 }, iColB{ 0 }, iCnt{ 0 };
};

bool bVisited[21][21][21][21];
const int dRow[4] = { 0, 0, -1, 1 };
const int dCol[4] = { -1, 1, 0, 0 };
int iRowSize, iColSize;

bool IsIn(const int& _iRow, const int& _iCol)
{
    if (_iRow >= 0 && _iRow < iRowSize && _iCol >= 0 && _iCol < iColSize)
        return true;

    return false;
}

int BFS(const vector<vector<char>>& _vecBoard, const COINS& tCoins)
{
    queue<COINS> qBFS;
    qBFS.push(tCoins);
    bVisited[tCoins.iRowA][tCoins.iColA][tCoins.iRowB][tCoins.iColB] = true;

    int iMinCnt = 100000000;

    while (!qBFS.empty())
    {
        COINS tCurCoins = qBFS.front();
        qBFS.pop();

        if (tCurCoins.iCnt >= 10)
            continue;

        for (int iDir = 0; iDir < 4; iDir++)
        {
            int iNextRowA = tCurCoins.iRowA + dRow[iDir];
            int iNextColA = tCurCoins.iColA + dCol[iDir];
            int iNextRowB = tCurCoins.iRowB + dRow[iDir];
            int iNextColB = tCurCoins.iColB + dCol[iDir];

            if (!IsIn(iNextRowA, iNextColA) && IsIn(iNextRowB, iNextColB) || IsIn(iNextRowA, iNextColA) && !IsIn(iNextRowB, iNextColB))
            {
                if (tCurCoins.iCnt + 1 > 10)
                {
                    return -1;
                }
                else
                {
                    return tCurCoins.iCnt + 1;
                }
            }

            if (!IsIn(iNextRowA, iNextColA) && !IsIn(iNextRowB, iNextColB))
                continue;
                
            if (bVisited[iNextRowA][iNextColA][iNextRowB][iNextColB] == true)
                continue;

            if (_vecBoard[iNextRowA][iNextColA] == '#')
            {
                iNextRowA = tCurCoins.iRowA;
                iNextColA = tCurCoins.iColA;
            }
            if (_vecBoard[iNextRowB][iNextColB] == '#')
            {
                iNextRowB = tCurCoins.iRowB;
                iNextColB = tCurCoins.iColB;
            }

            bVisited[iNextRowA][iNextColA][iNextRowB][iNextColB] = true;
            qBFS.push({ iNextRowA, iNextColA, iNextRowB, iNextColB, tCurCoins.iCnt + 1 });
        }
    }

    return -1;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> iRowSize >> iColSize;

    int iCheck{0};
    COINS tCoins{};
    vector<vector<char>> vecBoard(iRowSize, vector<char>(iColSize));
    for (int iRow = 0; iRow < iRowSize; iRow++)
    {
        for (int iCol = 0; iCol < iColSize; iCol++)
        {
            cin >> vecBoard[iRow][iCol];

            if ('o' == vecBoard[iRow][iCol])
            {
                if (0 == iCheck)
                {
                    tCoins.iRowA = iRow;
                    tCoins.iColA = iCol;
                    iCheck++;
                }
                else
                {
                    tCoins.iRowB = iRow;
                    tCoins.iColB = iCol;
                }
            }
        }
    }

    vector<vector<bool>> vecVisitedBoard(iRowSize, vector<bool>(iColSize, false));
    cout << BFS(vecBoard, tCoins);
    
    return 0;
}
