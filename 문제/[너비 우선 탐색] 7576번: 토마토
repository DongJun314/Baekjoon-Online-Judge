*** 핵심 ***
1. 문제에 Row Col을 햇깔리지 않기

======================================================

#include <iostream>
#include <vector>
#include <queue>
using namespace std;

int dRow[4] = { -1, 0, 1, 0 };
int dCol[4] = { 0, -1, 0, 1 };

struct POSITION
{
    int Row, Col, Day; // Day를 구조체에 포함
};

int BFS(vector<vector<int>>& TomatoBox)
{
    const int iRowSize = TomatoBox.size();
    const int iColSize = TomatoBox[0].size();

    queue<POSITION> qBFS;

    // 1. 처음에 익어있는 토마토들을 큐에 삽입
    for (int row = 0; row < iRowSize; row++)
    {
        for (int col = 0; col < iColSize; col++)
        {
            if (TomatoBox[row][col] == 1)
            {
                qBFS.push({ row, col, 0 });
            }
        }
    }

    int iDepth = 0;

    // 2. BFS 진행
    while (!qBFS.empty())
    {
        POSITION cur = qBFS.front();
        qBFS.pop();

        iDepth = cur.Day;

        for (int dir = 0; dir < 4; dir++)
        {
            int nextRow = cur.Row + dRow[dir];
            int nextCol = cur.Col + dCol[dir];

            if (nextRow < 0 || nextRow >= iRowSize) continue;
            if (nextCol < 0 || nextCol >= iColSize) continue;

            if (TomatoBox[nextRow][nextCol] != 0) continue; // 0인 경우만 퍼질 수 있음

            TomatoBox[nextRow][nextCol] = 1;
            qBFS.push({ nextRow, nextCol, cur.Day + 1 });
        }
    }

    // 3. BFS 끝난 후 아직 안 익은 토마토(0)가 있으면 -1
    for (int row = 0; row < iRowSize; row++)
    {
        for (int col = 0; col < iColSize; col++)
        {
            if (TomatoBox[row][col] == 0)
                return -1;
        }
    }

    return iDepth;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int iCol, iRow;
    cin >> iCol >> iRow; // 문제에서 입력 순서가 "가로, 세로"라 (M, N) 이거 반대로 받으면 오답납니다.

    vector<vector<int>> TomatoBox(iRow, vector<int>(iCol));
    for (int row = 0; row < iRow; row++)
    {
        for (int col = 0; col < iCol; col++)
        {
            cin >> TomatoBox[row][col];
        }
    }

    cout << BFS(TomatoBox);
    return 0;
}
