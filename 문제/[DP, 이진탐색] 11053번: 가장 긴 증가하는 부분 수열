** 핵심 **
1. LIS(Longest Increasing Subsequence) 최장 길이 증가 수열과 관련된 문제는 대게 DP 또는 이진 탐색 방법으로 푼다.
2. DP는 직관적이지만, 시간 복잡도O(N²)가 이진 탐색O(N log N)에 비해 길어, 수열 크기가 많으면 많을 수록 시간 초과 같은 문제가 발생한다.

==========================================

1. DP 풀이 방법
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int FindMaxLengthArray(const vector<int>& vecArray)
{
    //vecArray = { 10, 20, 10, 30, 20, 50 }
    // DP      = { 1,  2,  1,  3,  1,  4};
    vector<int> DP(vecArray.size(), 1);
    
    int iMaxAns = { 0 };
    for (int i = 0; i < vecArray.size(); ++i)
    {
        for (int j = 0; j < i; j++)
        {
            if (vecArray[i] > vecArray[j]) // i == 5, j == 1
            {
                DP[i] = max(DP[i], DP[j] + 1); // dp[5] == max(dp[5], dp[0] + 1)
            }
        }
        iMaxAns = max(iMaxAns, DP[i]);
    }
    return iMaxAns;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int iArraySize;
    cin >> iArraySize;

    vector<int> vecArray(iArraySize, 0);
    
    for (int i = 0; i < iArraySize; i++)
    {
        cin >> vecArray[i];
    }

    cout << FindMaxLengthArray(vecArray);

    return 0;
}

==========================================

2. 이진탐색 풀이 방법
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    //{ 10, 20, 30, 15, 50 }
    vector<int> tails;  // LIS의 "꼬리 값들"을 저장
    for (int x : a) {
        auto it = lower_bound(tails.begin(), tails.end(), x);
        if (it == tails.end()) {
            tails.push_back(x);  // 가장 큰 값이면 뒤에 추가
        }
        else {
            *it = x;             // 적절한 위치에 교체 → 끝값 최소화
        }
    }

    cout << (int)tails.size() << "\n";
    return 0;
}
